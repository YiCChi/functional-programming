# 関数型プログラミングとは

> 関数型プログラミングは、純粋な関数を使用したプログラミングです。数学的関数。

ネットで検索すると、簡単に次の定義が見つかります。

> (純粋な) 関数は、同じ入力が与えられると常に同じ出力を返し、目に見える副作用がないプロシージャです。

「副作用」という用語にはまだ具体的な意味はありませんが (正式な定義については今後説明します)、重要なのは、ある種の直観を持つことです。ファイルを開いたり、データベースに書き込んだりすることについて考えてみましょう。

今は便宜上、関数が値を返す以外に行う**すべてのこと**を副作用だと定義しましょう。

純粋関数のみを使用するプログラムの構造はどうなっているのでしょう？

関数型プログラムはパイプラインのように記述されることが多いです：

```ts
const program = pipe(
  input,
  f1, // 純粋関数
  f2, // 純粋関数
  f3, // 純粋関数
  ...
)
```

上記のプログラムは何をやっているかというと、最初の関数`f1`に`input`を渡し、その関数の戻り値を関数`f2`に渡し、`f2`の戻り値を関数`f3`に渡しています。後は繰り返しです。

Demo

[`00_pipe_and_flow.ts`](../00_pipe_and_flow.ts)

このスタイルでコードを構築するときに、関数型プログラミングがどのようにツールとして利用できるかを見ていきます。

関数型プログラミングとは何かを理解するだけでなく、その目的を理解することも重要です。

関数型プログラミングの目標は、形式モデル(formal models)を使用して**システムの複雑さを緩和すること**です。それと同時に**コードのプロパティ**とリファクタリングの容易性にも注意を払っています。

> 関数型プログラミングは、プログラム構築の裏にある数学知識を理解するのに役立ちます。
>
> - コンポジションできるコードの書き方
> - 副作用の推論
> - 一貫性があり、一般的で、アドホック（一時的な、特殊な）ではないAPIの書き方

コードのプロパティに注意を払うとはどういう意味でしょう？例で見てみましょう:

**例**：

配列の`map`メソッドが`for`ループよりも「関数的」であると言えるのはなぜでしょう？

```ts
// input
const xs: Array<number> = [1, 2, 3];

// 変換
const double = (n: number): number => n * 2;

// 結果: `xs`の各要素を倍にした配列が欲しい
const ys: Array<number> = [];
for (let i = 0; i <= xs.length; i++) {
  ys.push(double(xs[i]));
}
```

`for`ループが柔軟性が高く、以下の変更ができます：

- 開始インデックス，`let i = 0`
- ループ条件，`i < xs.length`
- ステップ変化， `i++`

一方で、これは、エラーが発生する可能性があり、戻り値についての保証がないことも意味しています。

**クイズ**。`for`ループは正しいですか？

> [答え](../quiz-answers/for-loop.md)

`map`で書き直しましょう。

```ts
// input
const xs: Array<number> = [1, 2, 3];

// 変換
const double = (n: number): number => n * 2;

// 結果: 各`xs`no要素が倍になる配列が欲しい
const ys: Array<number> = xs.map(double);
```

`map`は`for`より、少々柔軟性が欠けていますが、次の保証がされています。

- 入力配列のすべての要素が処理されます。
- 結果の配列には、常に入力配列と同じ数の要素が含まれます。

関数型プログラミングでは、詳細の実現よりもコードのプロパティに重点を置きます。**制限があるからこそ**，`map`は興味深いです。

`for`ではなく`map`を含む PR をレビューする方がいかに簡単かを考えてみましょう。
