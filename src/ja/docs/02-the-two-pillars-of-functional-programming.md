# 関数型プログラミングの2つの柱

関数型プログラミングは次の2つの柱に基づいています：

- 参照透過性
- 合成（ユニバーサルデザインパターンとして）

ここから説明していくすべての内容は、上記の2点から直接的または間接的に導き出されます。

## 参照透過性

> 定義：プログラムの動作を変更せずに式を対応する値に置き換えることができる場合、その式は _参照透過的_ であると言われます。

**例** （参照透過性は純粋関数を使用することを意味します）

```ts
const double = (n: number): number => n * 2;

const x = double(2);
const y = double(2);
```

式`double(2)`は、4に置き換えることができるため、参照透過性を持っています。

したがって、次のリファクタリングができます：

```ts
const x = 4;
const y = x;
```

すべての式が参照透過性を持っているわけではないです。例を見てみましょう。

**例** （参照透過性は例外を投げないことを意味します）

```ts
const inverse = (n: number): number => {
  if (n === 0) throw new Error('cannot divide by zero');
  return 1 / n;
};

const x = inverse(0) + 1;
```

`inverse(0)`をその値に置き換えることはできないため、参照透過性を持っていません。

**例** （参照透過性は不変のデータ構造を使用することが必要です）

```ts
const xs = [1, 2, 3];

const append = (xs: Array<number>): void => {
  xs.push(4);
};

append(xs);

const ys = xs;
```

最後の行の`xs`は、`append`の呼び出しによって変更されたため、初期値の`[1, 2, 3]`に置き換えることができません。

参照透過性はなぜそれほど重要なのでしょうか？参照透過性を持つことによって、次のことが可能になるからです：

- **コードを局所で推論する**（コードの断片を理解するために、外部コンテキストを知る必要がありません）
- プログラムの動作を変更せずにリ**ファクタリングする**

**クイズ**：次のプログラムがあるとします。

```ts
// TypeScript では、`declare`を使用すると、具体的な実装を書かずに宣言できます。
declare const question: (message: string) => Promise<string>;

const x = await question('What is your name?');
const y = await question('What is your name?');
```

我可以进行如下重构吗？程序的行为是否会改变？

下記のようにリファクタリングできますか？プログラムの動作に変更はありますか？

```ts
const x = await question('What is your name?');
const y = x;
```

答えは、`question`の実装を読まない限り分からないです。

見ての通り、参照透過性を持っていないプログラムのリファクタリングには、十分な注意を払って行う必要があります。
関数型プログラミングでは、すべての式に参照透過性を持っているため、リファクタリングするための認知負荷が軽減されます。

## 合成

関数型プログラミングの基本的なパターンは _合成_ です。特定なタスクを実行するための小さなコードのユニットを、より大きく複雑なユニットに合成します。

考えられる「最小から最大へ」の構成パターンの例：

- 2つ以上のプリミティブ値（数値または文字列）を合成する
- 2つ以上の関数を合成する
- プログラム全体を合成する

最後の例では、 _モジュール型プログラミング（modular programming）_ について話すことができます。

> モジュール型プログラミングとは、小さなプログラムをつなぎ合わせて、より大きなプログラムを構築するプロセスのことです。 - Simon Peyton Jones

このプログラミングスタイルは、コンビネータ（combinator）を使用することで実現できます。

**combinator**という用語は[combinator pattern](https://wiki.haskell.org/Combinator)を指しています：

> ものを組み合わせるという発想を中心としたライブラリの整理スタイル。通常、型`T`、`T`のプリミティブ値、および**コンビネータ**。コンビネータは`T`の値を組み合わせて、`T`のより複雑な値を構築できます。

コンビネータの一般的な概念はかなり曖昧で、さまざまな形式がありますが、最も単純な形式は次のとおりです：

```ts
combinator: Thing -> Thing
```

**例** 関数 `double` は2つの数値を結合しています。

コンビネータの目的は、すでに定義されているものから新しいものを作り出すことです。

コンビネータの結果を再び入力として渡すことができるため、組み合わせの可能性が爆発的に増えていきますので、このパターンが非常に強力です。

**例**：

```ts
import { pipe } from 'fp-ts/function';

const double = (n: number): number => n * 2;

console.log(pipe(2, double, double, double)); // => 16
```

したがって、機能モジュールでよく見られる一般的な設計は次のとおりです：

- `T`のモデル
- `T`のプリミティブ値の小さなセット
- プリミティブ値をより複雑な構造に結合するための一連のコンビネータ

このようなモジュールを実装してみましょう。

**Demo**：

[`01_retry.ts`](../01_retry.ts)

デモからわかるように、わずか3つのプリミティブと2つのコンビネータを使用して、かなり複雑なポリシーを表現することができました。

すでに定義されているものに新しいプリミティブ（または新しいコンビネータ）を1つ追加するだけで、表現の可能性が指数関数的に増加することもわかります。

`01_retry.ts`の2つのコンビネータのうち、特に`concat` について言及します。`concat`は、非常に強力な関数型プログラミングの抽象化であるセミグループ（semigroup）と関連しています。
