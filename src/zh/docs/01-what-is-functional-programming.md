# 什么是函数式编程

> 函数式编程是使用纯函数进行编程。数学意义上的函数。

在网上很简单地就能找到如下定义：

> (纯)函数是一个过程，给定相同的输入总是返回相同的输出，没有任何可观察到的副作用。

虽然现在"副作用"这个术语还没有任何具体的含义（将来我们会看到如何给出正式的定义），但重要的是拥有某种感觉。思考一下打开文件或向数据库写入数据。

目前，我们可以局限地理解为，副作用是函数除了返回一个值之外所做的**任何事情**。

只使用纯函数的程序的结构是什么样的?

函数式的程序往往像在写 **管道（pipeline）** 一样：

```ts
const program = pipe(
  input,
  f1, // 纯函数
  f2, // 纯函数
  f3, // 纯函数
  ...
)
```

上面的程序用语言描述就是，`input`被传递给了第一个函数`f1`，该函数的返回值被传递给了第二个函数`f2`，`f2`的返回值又被传递给了第三个函数`f3`。以此类推。

Demo

[`00_pipe_and_flow.ts`](../00_pipe_and_flow.ts)

我们将看到，在以这种风格构建代码时，函数式编程如何成为我们的工具。

除了理解函数式编程是什么之外，理解它的目标是什么也很重要。

函数式编程的目标是通过使用形式化模型(formal models)来**控制系统的复杂性**，并十分关注**代码的属性**和重构的容易性。

> 函数式编程帮助人们了解程序构建背后的数学知识：
>
> - 如何编写可组合的代码
> - 如何推理副作用
> - 如何编写一致的，通用的，而非临时的，特殊的(ad-hoc)API

什么叫更关注代码的属性？让我们举个例子。

**例**：

为什么我们说`Array.prototype.map`比`for`循环要更"函数式"？

```ts
// 输入
const xs: Array<number> = [1, 2, 3];

// 转换
const double = (n: number): number => n * 2;

// 结果：我想要一个新的数组，这个数组里的元素是把xs的每个元素翻倍后得到的结果
const ys: Array<number> = [];
for (let i = 0; i <= xs.length; i++) {
  ys.push(double(xs[i]));
}
```

`for`循环带来了很多的复杂性，我可以修改：

- 开始的索引，`let i = 0`
- 循环条件，`i < xs.length`
- 步长变化， `i++`

这同时意味着，我可能会引入某些**错误**，无法对返回值做出任何保证。

**测验**：`for`循环正确吗？

> [答案](../quiz-answers/for-loop.md)

让我们用`map`来重写它。

```ts
// 输入
const xs: Array<number> = [1, 2, 3];

// 转换
const double = (n: number): number => n * 2;

// 结果：我想要一个新的数组，这个数组里的元素是把xs的每个元素翻倍后得到的结果
const ys: Array<number> = xs.map(double);
```

我们可以注意到，跟`for`相比，`map`缺少了一些灵活性，但它为我们提供了一些保证:

- 输入数组的所有元素都会被处理
- 结果数组的元素数量始终与输入数组相同

在函数式编程中，更强调代码的属性而不是实现细节。**正是由于其局限性**，而让`map`显得有趣。

想想看当审查涉及循环的代码时，`map`会比`for`容易多少。
